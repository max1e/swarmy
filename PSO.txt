let Scene = {
    w : 600, h : 600, walls : [], swarm : [], N : 200, target : [590, 300], gbest : (0,0), gbest_obj : Infinity
}

class Wall {
    constructor(x1, y1, x2, y2){
        this.x1 = x1
        this.y1 = y1
        this.x2 = x2
        this.y2 = y2
    }
    draw(){
        strokeWeight(5)
        line(this.x1, this.y1, this.x2, this.y2)
    }
}

class Particle {
    constructor() {
        this.pos = createVector(random(105, Scene.w - 105), random(105, Scene.h - 105)); // position vector
        this.V = createVector(random(-1, 1), random(-1, 1)); // velocity vector
        this.max_speed = 2;

        this.c1 = 1.5; // Cognitive coefficient: weight for particle's best
        this.c2 = 1.5; // Social coefficient: weight for swarm's best
        this.w = 0.8; // Weight constant: how much particle keeps speed/direction

        this.pbest = this.pos.copy(); // Personal best position
        this.pbest_obj = objective_function(this.pbest.x, this.pbest.y); // Score of personal best position

        if (this.pbest_obj < Scene.gbest_obj) {
            Scene.gbest_obj = this.pbest_obj; // Global best score
            Scene.gbest = this.pbest.copy(); // Global best position
        }
    }
    
    draw() {
        strokeWeight(1);
        fill(0);
        ellipse(this.pos.x, this.pos.y, 5, 5);
    }

    step() {
        let r1 = random(0, 1);
        let r2 = random(0, 1);

        this.V.x = this.w * this.V.x + this.c1 * r1 * (this.pbest.x - this.pos.x) + this.c2 * r2 * (Scene.gbest.x - this.pos.x);
        this.V.y = this.w * this.V.y + this.c1 * r1 * (this.pbest.y - this.pos.y) + this.c2 * r2 * (Scene.gbest.y - this.pos.y);

        this.avoidWalls();
        
        this.V.limit(this.max_speed);
        let new_x = this.pos.x + this.V.x;
        let new_y = this.pos.y + this.V.y;

        if (canUpdateX(new_x, this.pos)) {
            this.pos.x = new_x;
        }
        if (canUpdateY(new_y, this.pos)) {
            this.pos.y = new_y;
        }

        for (let other of Scene.swarm) {
            if (other !== this) {
                let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
                let minDist = 5;
                if (d < minDist) {
                    let overlap = minDist - d;
                    let angle = atan2(this.pos.y - other.pos.y, this.pos.x - other.pos.x);
                    this.pos.x += cos(angle) * overlap;
                    this.pos.y += sin(angle) * overlap;
                }
            }
        }

        this.pos.x = constrain(this.pos.x, 0, Scene.w);
        this.pos.y = constrain(this.pos.y, 0, Scene.h);

        let new_obj = objective_function(this.pos.x, this.pos.y);
        if (new_obj < this.pbest_obj) {
            this.pbest = this.pos.copy();
            this.pbest_obj = new_obj;

            if (this.pbest_obj < Scene.gbest_obj) {
                Scene.gbest_obj = this.pbest_obj;
                Scene.gbest = this.pbest.copy();
            }
        }
    }

    avoidWalls() {
        for (let wall of Scene.walls) {
            let wallCenter = createVector((wall.x1 + wall.x2) / 2, (wall.y1 + wall.y2) / 2);
            let d = dist(this.pos.x, this.pos.y, wallCenter.x, wallCenter.y);
            let minDist = 50; // Distance threshold for wall avoidance
            if (d < minDist) {
                let repulseForce = p5.Vector.sub(this.pos, wallCenter);
                repulseForce.setMag((minDist - d) / minDist * this.max_speed * 2); // Increase the strength of the repulsive force
                this.V.add(repulseForce);
            }
        }
    }
}


// Check if X can be updated without collisions (assumes walls are defined with lowest values first)
function canUpdateX(new_x, current_pos) {
    for (let wall of Scene.walls) {
        if (current_pos.y > wall.y1 - 5 && current_pos.y < wall.y2 + 5) {
            if (new_x > wall.x1 - 5 && new_x < wall.x2 + 5) {
                return false;
            }
        }
    }
    return true;
}

// Check if Y can be updated without collisions (assumes walls are defined with lowest values first)
function canUpdateY(new_y, current_pos) {
    for (let wall of Scene.walls) {
        if (current_pos.x > wall.x1 - 5 && current_pos.x < wall.x2 + 5) {
            if (new_y > wall.y1 - 5 && new_y < wall.y2 + 5) {
                return false;
            }
        }
    }
    return true;
}


// Objective function: returns score based on position
function objective_function(x, y){
    return dist( x, y, Scene.target[0], Scene.target[1] )
}

function setup(){
    Scene.swarm = []
    Scene.walls = []
  
	createCanvas( Scene.w, Scene.h )
    
    // Create walls
    Scene.walls.push (new Wall(100, 100, 500, 100))
    Scene.walls.push (new Wall(100, 100, 100, 500))
    Scene.walls.push (new Wall(100, 500, 500, 500))
    
    Scene.walls.push (new Wall(500, 100, 500, 275))
    Scene.walls.push (new Wall(500, 325, 500, 500))
  
	for( let _ of Array(Scene.N) ){
		Scene.swarm.push( new Particle() )
	}
}

function draw(){
	background( 220 )
    
    run_model()
}

function run_model(){
      for( let p of Scene.swarm ){
          p.step()
          p.draw()
      }
      
      for ( let wall of Scene.walls ){
          wall.draw()
      }
      
      // Print the target spot as a red dot
      strokeWeight(0)
	  fill( 255, 0, 0 )
	  ellipse( Scene.target[0], Scene.target[1], 7, 7 )
}